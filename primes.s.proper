        .data
        .globl  prime
prime:  .fill   1001,4,0                # int[] prime
        .globl  LF
LF:     .fill   1,4,0                   # int LF
        .text
        .globl  find_primes             
find_primes:
        enter   $8,$0                   # Start function find_primes
                                        # Start for-statement
        leal    -4(%ebp),%eax           # i1
        pushl   %eax                    
        movl    $2,%eax                 # 2
        popl    %edx                    
        movl    %eax,(%edx)             #   =
.L0001:                                 
        movl    -4(%ebp),%eax           # i1
        pushl   %eax                    
        movl    $1000,%eax              # 1000
        popl    %ecx                    
        cmpl    %eax,%ecx               
        movl    $0,%eax                 
        setle   %al                     # Test <=
        cmpl    $0,%eax                 
        je      .L0002                  
                                        # Start for-statement
        leal    -8(%ebp),%eax           # i2
        pushl   %eax                    
        movl    $2,%eax                 # 2
        pushl   %eax                    
        movl    -4(%ebp),%eax           # i1
        movl    %eax,%ecx               
        popl    %eax                    
        imull   %ecx,%eax               # Compute *
        popl    %edx                    
        movl    %eax,(%edx)             #   =
.L0003:                                 
        movl    -8(%ebp),%eax           # i2
        pushl   %eax                    
        movl    $1000,%eax              # 1000
        popl    %ecx                    
        cmpl    %eax,%ecx               
        movl    $0,%eax                 
        setle   %al                     # Test <=
        cmpl    $0,%eax                 
        je      .L0004                  
        movl    -8(%ebp),%eax           # i2
        leal    prime,%edx              # prime[...]
        leal    (%edx,%eax,4),%eax      
        pushl   %eax                    
        movl    $0,%eax                 # 0
        popl    %edx                    
        movl    %eax,(%edx)             #   =
        leal    -8(%ebp),%eax           # i2
        pushl   %eax                    
        movl    -8(%ebp),%eax           # i2
        pushl   %eax                    
        movl    -4(%ebp),%eax           # i1
        movl    %eax,%ecx               
        popl    %eax                    
        addl    %ecx,%eax               # Compute +
        popl    %edx                    
        movl    %eax,(%edx)             #   =
        jmp     .L0003                  
.L0004:                                 # End for-statement
        leal    -4(%ebp),%eax           # i1
        pushl   %eax                    
        movl    -4(%ebp),%eax           # i1
        pushl   %eax                    
        movl    $1,%eax                 # 1
        movl    %eax,%ecx               
        popl    %eax                    
        addl    %ecx,%eax               # Compute +
        popl    %edx                    
        movl    %eax,(%edx)             #   =
        jmp     .L0001                  
.L0002:                                 # End for-statement
.exit$find_primes:
        leave                           
        ret                             # End function find_primes
        .globl  mod                     
mod:    enter   $0,$0                   # Start function mod
        movl    8(%ebp),%eax            # a
        pushl   %eax                    
        movl    8(%ebp),%eax            # a
        pushl   %eax                    
        movl    12(%ebp),%eax           # b
        movl    %eax,%ecx               
        popl    %eax                    
        cdq                             
        idivl   %ecx                    # Compute /
        pushl   %eax                    
        movl    12(%ebp),%eax           # b
        movl    %eax,%ecx               
        popl    %eax                    
        imull   %ecx,%eax               # Compute *
        movl    %eax,%ecx               
        popl    %eax                    
        subl    %ecx,%eax               # Compute -
        jmp     .exit$mod               # Return-statement
.exit$mod:
        leave                           
        ret                             # End function mod
        .globl  n_chars                 
n_chars:
        enter   $0,$0                   # Start function n_chars
                                        # Start if-statement
        movl    8(%ebp),%eax            # a
        pushl   %eax                    
        movl    $0,%eax                 # 0
        popl    %ecx                    
        cmpl    %eax,%ecx               
        movl    $0,%eax                 
        setl    %al                     # Test <
        cmpl    $0,%eax                 
        je      .L0005                  
        movl    $1,%eax                 # 1
        pushl   %eax                    
        movl    8(%ebp),%eax            # a
        negl    %eax                    # Compute prefix -
        pushl   %eax                    # Push parameter #1
        call    n_chars                 # Call n_chars
        addl    $4,%esp                 # Remove parameters
        movl    %eax,%ecx               
        popl    %eax                    
        addl    %ecx,%eax               # Compute +
        jmp     .exit$n_chars           # Return-statement
.L0005:                                 # End if-statement
                                        # Start if-statement
        movl    8(%ebp),%eax            # a
        pushl   %eax                    
        movl    $9,%eax                 # 9
        popl    %ecx                    
        cmpl    %eax,%ecx               
        movl    $0,%eax                 
        setle   %al                     # Test <=
        cmpl    $0,%eax                 
        je      .L0006                  
        movl    $1,%eax                 # 1
        jmp     .exit$n_chars           # Return-statement
.L0006:                                 # End if-statement
        movl    8(%ebp),%eax            # a
        pushl   %eax                    
        movl    $10,%eax                # 10
        movl    %eax,%ecx               
        popl    %eax                    
        cdq                             
        idivl   %ecx                    # Compute /
        pushl   %eax                    # Push parameter #1
        call    n_chars                 # Call n_chars
        addl    $4,%esp                 # Remove parameters
        pushl   %eax                    
        movl    $1,%eax                 # 1
        movl    %eax,%ecx               
        popl    %eax                    
        addl    %ecx,%eax               # Compute +
        jmp     .exit$n_chars           # Return-statement
.exit$n_chars:
        leave                           
        ret                             # End function n_chars
        .globl  pn                      
pn:     enter   $4,$0                   # Start function pn
                                        # Start for-statement
        leal    -4(%ebp),%eax           # i
        pushl   %eax                    
        movl    8(%ebp),%eax            # v
        pushl   %eax                    # Push parameter #1
        call    n_chars                 # Call n_chars
        addl    $4,%esp                 # Remove parameters
        pushl   %eax                    
        movl    $1,%eax                 # 1
        movl    %eax,%ecx               
        popl    %eax                    
        addl    %ecx,%eax               # Compute +
        popl    %edx                    
        movl    %eax,(%edx)             #   =
.L0007:                                 
        movl    -4(%ebp),%eax           # i
        pushl   %eax                    
        movl    12(%ebp),%eax           # w
        popl    %ecx                    
        cmpl    %eax,%ecx               
        movl    $0,%eax                 
        setle   %al                     # Test <=
        cmpl    $0,%eax                 
        je      .L0008                  
        movl    $32,%eax                # 32
        pushl   %eax                    # Push parameter #1
        call    putchar                 # Call putchar
        addl    $4,%esp                 # Remove parameters
        leal    -4(%ebp),%eax           # i
        pushl   %eax                    
        movl    -4(%ebp),%eax           # i
        pushl   %eax                    
        movl    $1,%eax                 # 1
        movl    %eax,%ecx               
        popl    %eax                    
        addl    %ecx,%eax               # Compute +
        popl    %edx                    
        movl    %eax,(%edx)             #   =
        jmp     .L0007                  
.L0008:                                 # End for-statement
        movl    8(%ebp),%eax            # v
        pushl   %eax                    # Push parameter #1
        call    putint                  # Call putint
        addl    $4,%esp                 # Remove parameters
.exit$pn:
        leave                           
        ret                             # End function pn
        .globl  and                     
and:    enter   $0,$0                   # Start function and
                                        # Start if-statement
        movl    8(%ebp),%eax            # a
        cmpl    $0,%eax                 
        je      .L0010                  
        movl    12(%ebp),%eax           # b
        jmp     .exit$and               # Return-statement
        jmp     .L0009                  
.L0010:                                 #   else-part
        movl    $0,%eax                 # 0
        jmp     .exit$and               # Return-statement
.L0009:                                 # End if-statement
.exit$and:
        leave                           
        ret                             # End function and
        .globl  print_primes            
print_primes:
        enter   $8,$0                   # Start function print_primes
        leal    -4(%ebp),%eax           # n_printed
        pushl   %eax                    
        movl    $0,%eax                 # 0
        popl    %edx                    
        movl    %eax,(%edx)             #   =
                                        # Start for-statement
        leal    -8(%ebp),%eax           # i
        pushl   %eax                    
        movl    $1,%eax                 # 1
        popl    %edx                    
        movl    %eax,(%edx)             #   =
.L0011:                                 
        movl    -8(%ebp),%eax           # i
        pushl   %eax                    
        movl    $1000,%eax              # 1000
        popl    %ecx                    
        cmpl    %eax,%ecx               
        movl    $0,%eax                 
        setle   %al                     # Test <=
        cmpl    $0,%eax                 
        je      .L0012                  
                                        # Start if-statement
        movl    -8(%ebp),%eax           # i
        leal    prime,%edx              # prime[...]
        movl    (%edx,%eax,4),%eax      
        cmpl    $0,%eax                 
        je      .L0013                  
                                        # Start if-statement
        movl    -4(%ebp),%eax           # n_printed
        pushl   %eax                    
        movl    $0,%eax                 # 0
        popl    %ecx                    
        cmpl    %eax,%ecx               
        movl    $0,%eax                 
        setg    %al                     # Test >
        pushl   %eax                    # Push parameter #2
        movl    $10,%eax                # 10
        pushl   %eax                    # Push parameter #2
        movl    -4(%ebp),%eax           # n_printed
        pushl   %eax                    # Push parameter #1
        call    mod                     # Call mod
        addl    $8,%esp                 # Remove parameters
        pushl   %eax                    
        movl    $0,%eax                 # 0
        popl    %ecx                    
        cmpl    %eax,%ecx               
        movl    $0,%eax                 
        sete    %al                     # Test ==
        pushl   %eax                    # Push parameter #1
        call    and                     # Call and
        addl    $8,%esp                 # Remove parameters
        cmpl    $0,%eax                 
        je      .L0014                  
        movl    LF,%eax                 # LF
        pushl   %eax                    # Push parameter #1
        call    putchar                 # Call putchar
        addl    $4,%esp                 # Remove parameters
.L0014:                                 # End if-statement
        movl    $32,%eax                # 32
        pushl   %eax                    # Push parameter #1
        call    putchar                 # Call putchar
        addl    $4,%esp                 # Remove parameters
        movl    $3,%eax                 # 3
        pushl   %eax                    # Push parameter #2
        movl    -8(%ebp),%eax           # i
        pushl   %eax                    # Push parameter #1
        call    pn                      # Call pn
        addl    $8,%esp                 # Remove parameters
        leal    -4(%ebp),%eax           # n_printed
        pushl   %eax                    
        movl    -4(%ebp),%eax           # n_printed
        pushl   %eax                    
        movl    $1,%eax                 # 1
        movl    %eax,%ecx               
        popl    %eax                    
        addl    %ecx,%eax               # Compute +
        popl    %edx                    
        movl    %eax,(%edx)             #   =
.L0013:                                 # End if-statement
        leal    -8(%ebp),%eax           # i
        pushl   %eax                    
        movl    -8(%ebp),%eax           # i
        pushl   %eax                    
        movl    $1,%eax                 # 1
        movl    %eax,%ecx               
        popl    %eax                    
        addl    %ecx,%eax               # Compute +
        popl    %edx                    
        movl    %eax,(%edx)             #   =
        jmp     .L0011                  
.L0012:                                 # End for-statement
        movl    LF,%eax                 # LF
        pushl   %eax                    # Push parameter #1
        call    putchar                 # Call putchar
        addl    $4,%esp                 # Remove parameters
.exit$print_primes:
        leave                           
        ret                             # End function print_primes
        .globl  main                    
main:   enter   $4,$0                   # Start function main
        leal    LF,%eax                 # LF
        pushl   %eax                    
        movl    $10,%eax                # 10
        popl    %edx                    
        movl    %eax,(%edx)             #   =
        movl    $1,%eax                 # 1
        leal    prime,%edx              # prime[...]
        leal    (%edx,%eax,4),%eax      
        pushl   %eax                    
        movl    $0,%eax                 # 0
        popl    %edx                    
        movl    %eax,(%edx)             #   =
                                        # Start for-statement
        leal    -4(%ebp),%eax           # i
        pushl   %eax                    
        movl    $2,%eax                 # 2
        popl    %edx                    
        movl    %eax,(%edx)             #   =
.L0015:                                 
        movl    -4(%ebp),%eax           # i
        pushl   %eax                    
        movl    $1000,%eax              # 1000
        popl    %ecx                    
        cmpl    %eax,%ecx               
        movl    $0,%eax                 
        setle   %al                     # Test <=
        cmpl    $0,%eax                 
        je      .L0016                  
        movl    -4(%ebp),%eax           # i
        leal    prime,%edx              # prime[...]
        leal    (%edx,%eax,4),%eax      
        pushl   %eax                    
        movl    $1,%eax                 # 1
        popl    %edx                    
        movl    %eax,(%edx)             #   =
        leal    -4(%ebp),%eax           # i
        pushl   %eax                    
        movl    -4(%ebp),%eax           # i
        pushl   %eax                    
        movl    $1,%eax                 # 1
        movl    %eax,%ecx               
        popl    %eax                    
        addl    %ecx,%eax               # Compute +
        popl    %edx                    
        movl    %eax,(%edx)             #   =
        jmp     .L0015                  
.L0016:                                 # End for-statement
        call    find_primes             # Call find_primes
        call    print_primes            # Call print_primes
        movl    $0,%eax                 # 0
        pushl   %eax                    # Push parameter #1
        call    exit                    # Call exit
        addl    $4,%esp                 # Remove parameters
.exit$main:
        leave                           
        ret                             # End function main
